// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract TiffyAI is ERC20, Ownable, ReentrancyGuard {
    uint256 public constant MAX_SUPPLY = 10_000_000 * 1e18;
    address public rewardsWallet = 0xF27d595F962ed722F39889B23682B39F712B4Da8;
    address public blessingsWallet = 0x8e8f465cC81b87efE6C58Efb1A03Ff10c32bBf2d;
    address public liquidityWallet = 0x6a28ae01Ad12bC73D0c70E88D23CeEd6d6382D19;
    address public growthWallet = 0xed9b43bED20B063ae0966C0AEC446bc755fB84bA;

    uint256 public cooldownTime = 1 days;
    mapping(address => uint256) public lastClaimTime;
    mapping(address => uint256) public blueKeys;
    mapping(address => uint256) public goldKeys;

    constructor() ERC20("TiffyAI", "TIFFY") {
        _mint(msg.sender, MAX_SUPPLY);
    }

    function setCooldown(uint256 _cooldown) external onlyOwner {
        cooldownTime = _cooldown;
    }

    function claimBlueKey() external nonReentrant {
        require(block.timestamp >= lastClaimTime[msg.sender] + cooldownTime, "Cooldown active");
        lastClaimTime[msg.sender] = block.timestamp;
        blueKeys[msg.sender]++;
        if (blueKeys[msg.sender] >= 10) {
            blueKeys[msg.sender] -= 10;
            goldKeys[msg.sender]++;
        }
    }

    function claimReward(uint256 amount) external onlyOwner {
        _transfer(rewardsWallet, msg.sender, amount);
    }

    function claimGameReward(address to, uint256 amount) external onlyOwner {
        _transfer(rewardsWallet, to, amount);
    }

    function _transfer(address from, address to, uint256 amount) internal override {
        if (from == owner() || to == owner()) {
            super._transfer(from, to, amount);
        } else {
            uint256 burnFee = (amount * 5) / 1000;
            uint256 blessFee = (amount * 10) / 1000;
            uint256 growFee = (amount * 15) / 1000;
            uint256 sendAmount = amount - burnFee - blessFee - growFee;

            super._transfer(from, address(0), burnFee);
            super._transfer(from, blessingsWallet, blessFee);
            super._transfer(from, growthWallet, growFee);
            super._transfer(from, to, sendAmount);
        }
    }

    function distributeTreasure(address user, uint256 amount) external onlyOwner {
        _transfer(rewardsWallet, user, amount);
    }

    function paySlotWinner(address player, uint256 amount) external onlyOwner {
        _transfer(rewardsWallet, player, amount);
    }

    function emergencyWithdraw(uint256 amount) external onlyOwner {
        _transfer(address(this), msg.sender, amount);
    }

    function updateRewardWallet(address newWallet) external onlyOwner {
        rewardsWallet = newWallet;
    }

    function updateBlessingWallet(address newWallet) external onlyOwner {
        blessingsWallet = newWallet;
    }

    function updateGrowthWallet(address newWallet) external onlyOwner {
        growthWallet = newWallet;
    }

    function updateLiquidityWallet(address newWallet) external onlyOwner {
        liquidityWallet = newWallet;
    }

    function getMyKeys() external view returns (uint256 blue, uint256 gold) {
        return (blueKeys[msg.sender], goldKeys[msg.sender]);
    }
}
