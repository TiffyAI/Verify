// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";

contract TiffyAI is ERC20, Ownable {
    uint256 public constant MAX_SUPPLY = 1_000_000_000 * 10 ** 18;
    uint256 public constant FIXED_BNB_FEE = 0.002 ether; // ~$0.20
    uint256 public constant BURN_AMOUNT = 0.01 ether; // 0.01 TIFFY

    address public rewardsWallet = 0xF27d595F962ed722F39889B23682B39F712B4Da8;
    address public bestowedBlessingsWallet = 0x8e8f465cC81b87efE6C58Efb1A03Ff10c32bBf2d;
    address public treasuryGrowthWallet = 0xed9b43bED20B063ae0966C0AEC446bc755fB84bA;
    address public liquidityWallet = 0x6a28ae01Ad12bC73D0c70E88D23CeEd6d6382D19;

    constructor() ERC20("TiffyAI", "TIFFY") {
        _mint(rewardsWallet, (MAX_SUPPLY * 50) / 100); // 50% to Rewards
        _mint(msg.sender, (MAX_SUPPLY * 50) / 100);     // 50% to Deployer
    }

    receive() external payable {}

    function claimTiffy(address to, uint256 amount) external payable {
        require(msg.value == FIXED_BNB_FEE, "BNB fee required");

        // Distribute BNB
        payable(treasuryGrowthWallet).transfer(FIXED_BNB_FEE * 50 / 100); // $0.10
        payable(liquidityWallet).transfer(FIXED_BNB_FEE * 25 / 100);      // $0.05
        payable(bestowedBlessingsWallet).transfer(FIXED_BNB_FEE * 25 / 100); // $0.05

        // Send TIFFY and burn 0.01
        _transfer(owner(), to, amount - BURN_AMOUNT);
        _burn(owner(), BURN_AMOUNT);
    }

    function updateWallets(
        address _rewards,
        address _growth,
        address _liquidity,
        address _blessings
    ) external onlyOwner {
        rewardsWallet = _rewards;
        treasuryGrowthWallet = _growth;
        liquidityWallet = _liquidity;
        bestowedBlessingsWallet = _blessings;
    }

    function updateFixedFee(uint256 newFee) external onlyOwner {
        require(newFee <= 0.01 ether, "Too high"); // protect gas gouge
        assembly {
            sstore(FIXED_BNB_FEE.slot, newFee)
        }
    }

    function updateBurnAmount(uint256 newAmount) external onlyOwner {
        require(newAmount <= 0.1 ether, "Too high");
        assembly {
            sstore(BURN_AMOUNT.slot, newAmount)
        }
    }
}
